[
  
  {
    "title": "인프콘 네트워킹 준비 완료!",
    "url": "/posts/%EC%9D%B8%ED%94%84%EC%BD%98-%EB%84%A4%ED%8A%B8%EC%9B%8C%ED%82%B9-%EC%A4%80%EB%B9%84-%EC%99%84%EB%A3%8C!/",
    "categories": "",
    "tags": "INFCON, 네트워킹, 인프콘2024, 인프런, 랠릿",
    "date": "2024-07-15 00:00:00 +0900",
    





    
    "snippet": "랠릿 프로필 주소#인프콘2024 #인프런 #랠릿",
    "content": "랠릿 프로필 주소#인프콘2024 #인프런 #랠릿"
  },
  
  {
    "title": "HEIC 포맷을 JPG 로 CLI 를 통해서 변경하기",
    "url": "/posts/HEIC-%ED%8F%AC%EB%A7%B7%EC%9D%84-JPG-%EB%A1%9C-%EB%B3%80%EA%B2%BD-%ED%95%98%EA%B8%B0/",
    "categories": "",
    "tags": "CLI, MAC, HEIC, JPG",
    "date": "2024-05-27 00:00:00 +0900",
    





    
    "snippet": "HEIC 포맷을 JPG 로 변경하기가끔 아이폰으로 찍은 사진을 맥북에 에어드롭으로 전송하면 HEIC 포맷으로 저장되는 경우가 있다. 이런 경우, HEIC 포맷을 JPG 로 변경하고 싶을 때가 있다. 이때 CLI 를 사용하면 편리하게 변경할 수 있다.# HEIC 포맷을 JPG 로 변경sips -s format jpeg -s formatOptions be...",
    "content": "HEIC 포맷을 JPG 로 변경하기가끔 아이폰으로 찍은 사진을 맥북에 에어드롭으로 전송하면 HEIC 포맷으로 저장되는 경우가 있다. 이런 경우, HEIC 포맷을 JPG 로 변경하고 싶을 때가 있다. 이때 CLI 를 사용하면 편리하게 변경할 수 있다.# HEIC 포맷을 JPG 로 변경sips -s format jpeg -s formatOptions best image.heic --out image.jpg이렇게 하면 image.heic 파일이 image.jpg 로 변경 된다.HEIC 포맷은?HEIC(High Efficiency Image Container)는 고효율 이미지 파일 포맷으로, HEIF(High Efficiency Image Format) 표준을 따른다.HEIF는 MPEG(Moving Picture Experts Group)에서 개발한 이미지 표준으로, JPEG보다 더 높은 압축률을 제공하여 동일한 품질의 이미지를 더 작은 파일 크기로 저장할 수 있음.HEIC의 주요 특징:  높은 압축률: HEIC는 JPEG보다 최대 50% 더 높은 압축률을 제공하여 저장 공간을 절약.  화질 유지: 압축률이 높음에도 불구하고 JPEG와 동일한 수준의 화질을 유지.  다양한 기능 지원: 투명도, 16비트 색심도, 이미지 시퀀스(움짤과 유사) 등 다양한 기능을 지원.HEIC 이미지 표준:  HEIC는 MPEG-H Part 12(ISO/IEC 23008-12) 표준에 정의되어 있습니다. HEVC(High Efficiency Video Coding) 코덱을 사용하여 이미지를 압축하며, 이는 4K 및 8K 비디오 압축에도 사용되는 코덱이다.JPG(JPEG) 포맷은?JPG(JPEG)는 가장 널리 사용되는 이미지 파일 형식이다.Joint Photographic Experts Group에서 개발했고, 손실 압축 방식을 사용하여 파일 크기를 줄이는 대신 이미지 품질이 약간 저하될 수 있다.JPEG의 주요 특징:  24비트 색상 지원: 1600만 가지 이상의 색상 표현 가능  손실 압축: 파일 크기를 줄이기 위해 이미지 데이터 일부 손실  높은 호환성: 대부분의 기기 및 소프트웨어에서 지원  사진 저장에 적합: 풍부한 색상 표현과 적절한 파일 크기"
  },
  
  {
    "title": "개발자라면 Decimal과 부동소수점은 알아야지?",
    "url": "/posts/%EA%B0%9C%EB%B0%9C%EC%9E%90%EB%9D%BC%EB%A9%B4-%EA%BC%AD-%EC%95%8C%EC%95%84%EC%95%BC-%ED%95%A0-Decimal-%EB%8F%88-%EA%B3%84%EC%82%B0,-%EC%A0%9C%EB%8C%80%EB%A1%9C-%ED%95%98%EC%9E%90!/",
    "categories": "",
    "tags": "라이브러리",
    "date": "2024-05-23 00:00:00 +0900",
    





    
    "snippet": "부동소수점 함정에 주의금융 애플리케이션 개발 시, 정확한 계산 로직 구현은 필수 불가결하다. 부동소수점 자료형(Float, Double)은 근사치 계산으로 인해 금융 계산에 적합하지 않다. Decimal을 사용하여 이 문제를 해결하고 정확한 계산을 보장해야 한다.부동소수점 함정: IEEE 754 표준의 한계대부분의 프로그래밍 언어는 부동소수점 표현에 ...",
    "content": "부동소수점 함정에 주의금융 애플리케이션 개발 시, 정확한 계산 로직 구현은 필수 불가결하다. 부동소수점 자료형(Float, Double)은 근사치 계산으로 인해 금융 계산에 적합하지 않다. Decimal을 사용하여 이 문제를 해결하고 정확한 계산을 보장해야 한다.부동소수점 함정: IEEE 754 표준의 한계대부분의 프로그래밍 언어는 부동소수점 표현에 IEEE 754 표준을 따른다. 64비트 double precision은 부호(1비트), 지수(11비트), 가수(52비트)로 구성된다.  32비트 single precision은 64비트에 비해 표현 가능한 비트수가 절반이므로 정밀도가 상대적으로 떨어진다.예를 들어 0.1을 double precision 부동소수점으로 표현하면 다음과 같다.  부호: 0 (양수)  지수: 01111111011 (2진법) (-4 + 1023 bias = 1019)  가수: 1001100110011001100110011001100110011001100110011010 (2진법)따라서 0.1은 64비트 double precision 부동소수점으로 다음과 같이 표현된다.0 01111111011 1001100110011001100110011001100110011001100110011010문제는 0.1을 2진법으로 정확하게 표현할 수 없다는 점이다. 2진법으로는 1/10을 무한 소수로 표현해야 하므로, 컴퓨터는 이를 유한한 자릿수로 근사하여 저장한다. 이 과정에서 필연적으로 오차가 발생하며, 이는 금융 계산에 치명적인 오류를 야기할 수 있다.val num = 0.1 + 0.2println(num)  // 0.30000000000000004결과값은 0.3이 아니라 0.30000000000000004이다. 이러한 사소한 오차가 금융 로직에서 큰 문제를 일으킬 수 있다.Decimal: 정확한 금융 계산의 해결책Java 언어에서 BigDecimal은 문자열 형태의 10진수 값과 스케일(소수점 이하 자릿수)을 저장한다. 내부적으로는 BigInteger를 사용하여 정수부를 표현하고, 스케일 정보를 통해 소수점 위치를 관리한다. 이러한 구조 덕분에 BigDecimal은 0.1, 0.2와 같은 숫자를 정확하게 표현하고 연산할 수 있다.물론 장점만 있는 것이 아니다. 단점도 간단하게 말하자면 성능이 IEEE 754 보다 상대적으로 떨어진다는 점이다.하지만 2024년 현재, 컴퓨팅 리소스는 굉장히 발전했다. 또한 컴퓨터 리소스를 쉽게 제공하는 클라우드 업체도 많다. 그래서 여러 장단점을 따지며 사용하면 좋겠다.import java.math.BigDecimalval num1 = BigDecimal(\"0.1\")val num2 = BigDecimal(\"0.2\")val result = num1 + num2println(result)  // 0.3  위 예제코드는 코틀린 코드이다.결론금융 앱 개발 시, 정확한 계산 로직 구현은 필수다. 부동소수점 함정에 빠지지 말고 Decimal을 사용하여 안전하고 정확한 금융 서비스를 구현해야 한다."
  },
  
  {
    "title": "H264 표준 코덱과 구현체",
    "url": "/posts/H264-%ED%91%9C%EC%A4%80-%EC%BD%94%EB%8D%B1%EA%B3%BC-%EA%B5%AC%ED%98%84%EC%B2%B4/",
    "categories": "",
    "tags": "라이브러리",
    "date": "2024-05-17 00:00:00 +0900",
    





    
    "snippet": "FMPEG.wasm 라이브러리  장점          클라이언트 사이드에서 동작 (클라이언트 리소스를 사용해서 동영상을 인코딩하거나 디코딩)      단일 쓰레드와 멀티 쓰레드를 같이 제공하므로 상황에 맞는 것을 선택 가능      그 외 장점들이 표현되어 있네요.        우선,  ffmpeg의 h264는 내부적으로 **x264를 사용하게 됩니다...",
    "content": "FMPEG.wasm 라이브러리  장점          클라이언트 사이드에서 동작 (클라이언트 리소스를 사용해서 동영상을 인코딩하거나 디코딩)      단일 쓰레드와 멀티 쓰레드를 같이 제공하므로 상황에 맞는 것을 선택 가능      그 외 장점들이 표현되어 있네요.        우선,  ffmpeg의 h264는 내부적으로 **x264를 사용하게 됩니다.*  참고로 x264는 videolan 에서 h264 스펙을 구현한 라이브러리를 사용합니다.=&gt; 참고 링크: https://superuser.com/questions/1587136/what-is-the-different-of-h264-and-libx264openH264 vs. x264  라이선스:          openH264: BSD 2-Clause “Simplified” License (자유로운 사용 및 수정 가능)      x264: GNU GPL v2 (자유로운 사용 및 수정 가능, 단 파생 저작물도 GPL v2 라이선스를 따라야 함)        기능:          openH264: H.264 인코딩만 지원      x264: H.264 인코딩만 지원 (디코딩 기능 없음)        성능:          openH264: 경량, 실시간 처리에 적합, 모바일 환경에 최적화      x264: 고품질 인코딩, 높은 압축률, CPU 리소스 많이 필요        하드웨어 가속:          둘 다 하드웨어 가속 지원 (단, 사용하는 기기 및 환경에 따라 지원 여부 다름)      하드웨어 리소스 측면에서의 비교:      openH264: 경량 코덱이므로 일반적으로 적은 리소스를 필요로 합니다. 하드웨어 가속을 지원하므로 특히 모바일 장치에서 효율적으로 동작할 수 있습니다.        x264: 고성능 코덱이지만, 더 많은 리소스를 필요로 합니다. 더 높은 압축률과 품질을 원한다면 적절한 선택일 수 있지만, 일부 환경에서는 더 많은 CPU 리소스가 필요할 수 있습니다.  둘 다 CPU를 기반으로 동작하는 코덱 구현체 입니다.결론  ffmpeg.wasm: 웹 브라우저에서 비디오/오디오 처리가 필요할 때 유용합니다.  openH264: 가볍고 빠른 H.264 인코딩이 필요하며, 특히 모바일 환경에 적합합니다.  x264: 고품질 H.264 인코딩이 필요하고, CPU 리소스가 충분하다면 고려할 수 있습니다.추가 참고 사항  H.264는 비교적 오래된 코덱이며, 최근에는 H.265 (HEVC) 또는 AV1과 같은 더 효율적인 코덱이 많이 사용됩니다.  ffmpeg는 H.264 외에도 다양한 비디오/오디오 코덱을 지원합니다. 필요에 따라 적절한 코덱을 선택하여 사용할 수 있습니다.참고할만한 링크https://github.com/cisco/openh264/issues/2949https://ko.wikipedia.org/wiki/OpenH264https://ko.wikipedia.org/wiki/X264"
  },
  
  {
    "title": "스타트업에 대한 나의 생각",
    "url": "/posts/%EC%8A%A4%ED%83%80%ED%8A%B8%EC%97%85%EC%97%90-%EB%8C%80%ED%95%9C-%EB%82%98%EC%9D%98-%EC%83%9D%EA%B0%81/",
    "categories": "내생각",
    "tags": "",
    "date": "2024-05-06 00:00:00 +0900",
    





    
    "snippet": "회사 상황최근 회사 상황이 좋지 않아서 사업팀이 해체되었습니다.우리 회사는 최근 결정되어 있던 투자를 받지 못했습니다.그래서 자금 부족 문제로 인해 일부 인력이 이직해야 한다는 얘기가 나왔습니다.하지만 자금이 얼마나 부족하고 왜 사람들이 떠나야 하는지에 대해서는 팀원들에게 자세히 공개되지 않았습니다.저는 이 회사에서 이미 21개월을 근무했지만, 여전히...",
    "content": "회사 상황최근 회사 상황이 좋지 않아서 사업팀이 해체되었습니다.우리 회사는 최근 결정되어 있던 투자를 받지 못했습니다.그래서 자금 부족 문제로 인해 일부 인력이 이직해야 한다는 얘기가 나왔습니다.하지만 자금이 얼마나 부족하고 왜 사람들이 떠나야 하는지에 대해서는 팀원들에게 자세히 공개되지 않았습니다.저는 이 회사에서 이미 21개월을 근무했지만, 여전히 회사의 방향이나 목표가 뚜렷하지 않다는 느낌을 받고 있습니다.이런 상황에서는 공유와 소통이 소홀히 되고 있다는 느낌을 받습니다.본인이 생각하는 스타트업의 특성그렇다면 이 회사는 진정한 스타트업일까요?제가 알고 있는 스타트업은 빠르게 실험하고 적극적으로 도전하는 환경을 갖추고 있습니다.빠른 시도와 실패를 통해 배우는 문화가 정착되어 있죠.이를 통해 지속적인 성장과 발전을 이루는 것이 가능합니다.그러나 제가 다니는 회사는 이런 스타트업의 특성을 담고 있지 않습니다.결정은 중앙에서만 이뤄지고, 실패에 대한 회고가 부족하며, 팀원들이 자율적으로 일할 수 있는 환경이 부족합니다.또한 피드백을 제대로 주고받지 못해 공정한 의사결정이 이뤄지지 않는 것 같습니다.모든 것이 경영진에 의해 결정되고 진행되는데, 이러한 과정은 매우 무겁고 불편합니다.회사와 팀의 성장사람이 일을 하기 위한 가장 큰 동기는 무엇일까요?바로 자신의 일에 대한 주도성과 책임감일 것입니다. 자신의 결정과 역량을 발휘할 때, 일의 가치를 느낄 수 있습니다.그 반대로, 단순히 돈 받은 만큼 일을 한다고 생각하는 경우에는 일에 대한 열정과 책임감이 줄어들 수 있습니다.일의 결과물이 자신의 것이 아니고, 상사의 지시에 따르는 경우에는 더욱 그렇습니다.회사의 이익회사는 이익을 내야 합니다.이를 위해서는 좋은 팀원들을 고용하고 잘 관리해야 합니다.회사의 가치와 문화에 맞는 인재를 채용하고 유지하는 것이 중요합니다.핏이 맞지 않는 인재는 고용하지 않거나 해고해야 합니다.그리고 회사는 팀으로서의 성장과 발전을 위해 노력해야 한다고 생각합니다.결론저는 회사에서 팀으로서의 성장을 더욱 중요하게 생각합니다.팀원들이 자신의 역할을 맡고 책임감을 가지며 일할 수 있도록 환경을 조성하는 것이 회사의 이익에 큰 도움이 될 것이라고 믿습니다."
  },
  
  {
    "title": "대규모 시스템 설계 기초 - 사용자 수에 따른 규모 확장성",
    "url": "/posts/%EB%8C%80%EA%B7%9C%EB%AA%A8-%EC%8B%9C%EC%8A%A4%ED%85%9C-%EC%84%A4%EA%B3%84-%EA%B8%B0%EC%B4%88/",
    "categories": "책읽기, 대규모 시스템 설계 기초",
    "tags": "",
    "date": "2024-04-19 00:00:00 +0900",
    





    
    "snippet": "대규모 시스템 설계 기초내가 어느정도 알고 있는지 점검하기.대개 웹 애플리케이션은 클라이언트 서버 패턴이다.옛날에는 거의 단일 서버(PHP, JSP, etc)에서 클라이언트 / 서버 애플리케이션을 실행했다.하지만 근래에는 사용자 경험을 향상시키기 위해서 CSR(Client Side Rendering)이 나왔고, 그 다음엔 CSR 문제를 해결하기 위해 ...",
    "content": "대규모 시스템 설계 기초내가 어느정도 알고 있는지 점검하기.대개 웹 애플리케이션은 클라이언트 서버 패턴이다.옛날에는 거의 단일 서버(PHP, JSP, etc)에서 클라이언트 / 서버 애플리케이션을 실행했다.하지만 근래에는 사용자 경험을 향상시키기 위해서 CSR(Client Side Rendering)이 나왔고, 그 다음엔 CSR 문제를 해결하기 위해 SSR(Server Side Rendering)이 나왔다.SSR은 NextJS가 나오면서 옛날과는 다르게 렌더링만 담당하는 서버를 두고, HTML을 렌더링하기 위해 API 서버를 두는 방식으로 발전하였다.그러므로 프론트엔드 개발자도, 서버 개발자도 지속적으로 인프라 레벨을 공부해야한다.  단일 웹서비스 서버 구조          서버에서 모든 것을 처리한다.      웹 애플리케이션 서버, 데이터베이스 서버, 캐시 서버 등을 하나의 서버에서 처리한다.      병목 지점 발생시 스케일 업이라는 하드웨어 성능을 높이는 방법밖에 없다. - SPOF(Single Point of Failure)가 발생할 수 있다.        웹 서버 + 데이터베이스 서버 구조          웹 서버와 데이터베이스 서버를 분리한다.      이렇게 되면 스케일 아웃(서버 병렬 확장)이 가능하다.      LB, ALB 가 필요해진다.      RDBMS를 사용하면 자체적으로 Master-Slave 구조를 지원한다.      책 내용 정리수직적 규모확장 vs 수평적 규모 확장스케일 업: 단순 하드웨어 성능을 높이는 방법스케일 아웃: 서버를 병렬로 늘리는 방법수직적 규모 확장에는 한계가 있다. 한 대의 서버에 CPU나 메모리를 무한대로 증설할 방법은 없다.수직적 규모 확장법은 장애에 대한 자동복구(failover) 방안이나 다중화(re-dundancy) 방안이 없다. 서버에 장애가 발생하면 웹사이트/앱은 완전히 중단된다.로드밸런서  로드밸런서는 서버에 들어오는 트래픽을 분산시켜주는 장치이다.  사용자는 로드밸런서로 접근해(public IP) 서버로 접근한다.  서버는 private IP를 사용한다. 따라서 서버는 외부에서 직접 접근할 수 없다.데이터베이스 다중화  Master, Slave 구조를 대부분의 RDBMS가 지원한다. 데이터 원본은 주 서버에, 사본은 부 서버에 저장하는 방식이다.  쓰기 연산은 Master에서만 지원한다. 부 데이터베이스는 주 데이터베이스로부터 그 사본을 전달받으며, 읽기연산만을 지원한다.웹 계층과 데이터 계층에 대한 부분은 위의 글을 참조.아래는 응답시간(la-tency)을 개선해 볼 순서다.응답 시간은 캐시를 붙이고 정적 콘텐츠를 콘텐츠 전송 네트워크(Content Delivery Network, CDN)으로 옮기면 개선.캐시캐시는 값비싼 연산 결과 또는 자주 참조되는 데이터를 메모리 안에 두고, 다음에 같은 데이터를 요청할 때 빠르게 응답할 수 있도록 하는 기술이다.캐시 계층캐시 계층(cache tier)은 데이터가 잠시 보관되는 곳으로 데이터베이스보다 훨씬 빠르다.캐시 사용시 유의할 점  데이터 갱신은 자주 일어나지 않지만, 참조는 자주 일어나는 데이터에 캐시를 건다.  영속적으로 보관할 데이터를 캐시에 넣지 말자.  캐시 만료 정책을 설정하는 건 좋은 습관이다.  일관성은 어떻게 유지되는가? 저장소의 원본을 갱신하는 연산과 캐시를 갱신하는 연산이 단일 트랜잭션으로 처리되지 않는 경우 이 일관성은 깨질 수 있다.          이에 관련하여 Fackbook 논문 (Scaling Memcache at Facebook)을 참조하자.        장애에는 어떻게 대처할 것인가? 캐시 서버를 한 대만 두는 경우 해당 서버는 단일 장애 지점(Single Point of Failure, SPOF)이 되어버릴 가능성이 있다.  캐시 메모리는 얼마나 크게 잡을 것인가? 캐시 메모리가 너무 작으면 액세스 패턴에 따라서는 데이터가 너무 자주 캐시에서 밀려나버리므로 캐시의 성능이 떨어진다. 해결할 방법은 캐시 메모리를 과할당 하는 것이다.  데이터 방출 정책은 무엇인가? 캐시 데이터 방출 정책 중 LRU(Least Recently Used)가 가장 많이 사용된다. 다른 정책도 있으므로 적절하게 선택해야한다.CDN  CDN은 콘텐츠 전송 네트워크(Content Delivery Network)의 약자로, 전 세계에 분산된 서버에 콘텐츠를 저장해두고 사용자가 접근할 때 가장 가까운 서버에서 콘텐츠를 제공하는 기술이다.  CDN은 콘텐츠를 캐시하는 역할을 한다. 콘텐츠를 캐시하면 웹 서버에 대한 요청이 줄어들어 응답 시간이 단축된다.무상태 웹 계층  웹 계층을 수평적으로 확장하는 방법을 고민해보자. 이를 위해서는 상태 정보(사용자 세션 데이터와 같은)를 웹 계층에서 제거한다.  이렇게 하지 않으면 수평적으로 확장되었을 때 A 서버에 저장되어 있는 상태 정보가 B 서버로 이동되지 않아 사용자가 로그인 상태를 유지하지 못하는 문제가 발생한다.데이터 센터  가용성을 높이고 전 세계 어디서도 쾌적하게 사용할 수 있도록 하기 위해서 여러 데이터 센터를 지원하는 것이 필수다.  사용자는 장애가 없는 상황에서 가장 가까운 데이터 센터로 안내되는데, 통상 이 절차를 지리적 라우팅(geographic routing)이라고 한다.다중 데이터센터 아키텍처를 만들려면 몇 가지 기술적 난제를 해결해야 한다.  트래픽 우회: 올바른 데이터 센터로 트래픽을 보내는 효과적인 방법을 찾아야한다. GeoDNS, Anycast IP, BGP Anycast 등이 있다.  데이터 동기화  테스트와 배포: 여러 데이터 센터를 사용하도록 시스템이 구성된 상황이라면 웹 사이트 또는 애플리케이션을 여러 위치에서 테스트해보는 것이 중요하다.시스템을 더 큰 규모로 확장하기 위해서는 시스템의 컴포넌트를 분리하여, 각기 독립적으로 확장될 수 있도록 하여야 한다. 메시지 큐는 많은 실제 분산 시스템이 이 문제를 해결하기 위해 채용하고 있는 핵심적 전략 가운데 하나다.메시지 큐  메시지 큐는 시스템의 컴포넌트 간에 비동기적으로 메시지를 주고받을 수 있게 해주는 시스템이다.  메시지 큐는 시스템의 컴포넌트를 독립적으로 만들어준다. 컴포넌트 간의 결합도를 낮추어 시스템을 확장하기 쉽게 만들어준다.  보통 메시지 큐는 pub/sub 모델을 사용한다. 이 모델은 메시지를 발행하는 쪽(publisher)과 메시지를 구독하는 쪽(subscriber)으로 나뉜다.  발행하는 쪽, 구독하는 쪽이 분리되었기 때문에 독립적으로 확장할 수 있다.로그, 매트릭 그리고 자동화  로그와 매트릭은 시스템의 건강 상태를 확인하는 데 필수적이다.  로그는 시스템의 동작을 추적하고, 매트릭은 시스템의 성능을 측정한다.  로그와 매트릭을 수집하고 분석하는 것은 시스템의 성능을 개선하는 데 중요한 역할을 한다.데이터베이스의 규모 확장수직적 확장하드웨어 성능을 높이는 이 접근법에는 몇가지 심각한 약점이 있다.  하드웨어를 무한으로 증설할 수 없다.  SOF로 인한 위험성이 크다  비용이 많이 든다. 고성능 서버로 갈수록 가격이 기하급수적으로 올라간다.    수평적 확장    수평적 확장은 서버를 병렬으로 늘리는 방법이다.    수평적 확장은 샤딩이라고도 부른다.  샤딩은 데이터베이스를 여러 부분으로 나누어 각 부분을 별도의 서버에 저장하는 방식이다.샤딩 전략을 구현할 때 고려해야 할 가장 중요한 것은 샤딩 키(sharding key)를 어떻게 정하느냐 하는 것.  샤딩 키는 파티션 키(partition key)라고도 부른다.  데이터가 어떻게 분산될지 정하는 하나 이상의 컬럼으로 구성된다.샤딩 키를 선택할 때 고려해야 할 사항  데이터의 재 샤딩(resharding)  유명인사 문제  조인과 비정규화요약  웹 계층은 무상태 게층으로  모든 계층에 다중화 도입  가능한 많은 데이터를 캐시할 것  정적 콘텐츠는 CDN을 통해 서비스할 것  데이터 계층은 샤딩을 통해 그 규모를 확장할 것  각 계층은 독립적 서비스로 분할할 것  시스템을 지속적으로 모니터링하고, 자동화 도구들을 활용할 것"
  },
  
  {
    "title": "jekyll chirpy theme 사용법",
    "url": "/posts/how-to-write-a-new-post/",
    "categories": "깃허브블로그",
    "tags": "",
    "date": "2024-04-10 00:00:00 +0900",
    





    
    "snippet": "이름 지정과 경로새로운 파일의 이름은 YYYY-MM-DD-TITLE.EXTENSION 형식으로 작성하고, _posts 디렉토리에 위치해야합니다.파일의 EXTENSION은 .md 또는 .markdown이어야합니다.파일을 생성하기 위해서 시간을 아끼려면 Jekyll-Compose 를 사용할 수 있습니다.서문 작성파일의 맨 위에는 YAML Front Mat...",
    "content": "이름 지정과 경로새로운 파일의 이름은 YYYY-MM-DD-TITLE.EXTENSION 형식으로 작성하고, _posts 디렉토리에 위치해야합니다.파일의 EXTENSION은 .md 또는 .markdown이어야합니다.파일을 생성하기 위해서 시간을 아끼려면 Jekyll-Compose 를 사용할 수 있습니다.서문 작성파일의 맨 위에는 YAML Front Matter가 있어야합니다. 이것은 파일의 메타데이터를 정의하는데 사용됩니다.---title: TITLEdate: YYYY-MM-DD HH:MM:SS +/-TTTTcategories: [TOP_CATEGORIE, SUB_CATEGORIE]tags: [TAG]     # TAG names should always be lowercase---시간대(타임존)게시물의 작성일을 정확하게 기록하기 위해서는 _config.yml 파일 뿐만아니라 게시물의 서문에 시간대를 명시해야합니다.  +/-TTTT는 UTC 시간과의 차이를 나타냅니다. 예를 들어, 한국 시간은 +0900입니다.카테고리와 태그카테고리는 최대 두 개 요소를 포함하도록 디자인 되어있고, 태그는 0개에서 무한대를 사용할 수 있습니다.작성자 정보작성자 정보를 추가하려면 _data/authors.yml 파일에 작성자 정보를 추가해야합니다.&lt;author_id&gt;:  name: &lt;full name&gt;  twitter: &lt;twitter_of_author&gt;  url: &lt;homepage_of_author&gt;그런 다음 작성자를 지정하는 데 author를 사용하거나 여러 항목을 지정하는 데 authors를 사용합니다:author: &lt;작성자 아이디&gt;                     # 단일 항목의 경우# 또는authors: [&lt;작성자1 아이디&gt;, &lt;작성자2 아이디&gt;]   # 여러 항목의 경우목차 작성기본적으로 목차(TOC)는 포스트의 오른쪽 패널에 표시됩니다. 전역적으로 끄려면 _config.yml로 이동하여 변수 toc의 값을 false로 설정하세요. 특정 포스트의 목차를 끄려면 다음을 포스트의 프론트 매터에 추가하세요:---toc: false---댓글_config.yml 파일의 comments.active 변수에 의해서 글로벌 댓글 기능이 정의됩니다. 이 변수에 댓글 시스템을 선택한 후, 모든 게시물에 대해 댓글이 활성화 됩니다.또한, 특정 포스트의 댓글을 끄려면 다음을 포스트의 프론트 매터에 추가하세요:---comments: false---MermaidMermaid는 훌륭한 다이어그램 생성 도구입니다. 게시물에서 이를 활성화하려면 YAML 블록에 다음을 추가하십시오:---mermaid: true---이미지캡션이미지의 다음 줄에 기울임을 추가하면 캡션으로 처리되어 이미지 하단에 나타납니다.![이미지 설명](/경로/이미지)_이미지 캡션_크기이미지가 로드될 때 페이지 내용 레이아웃이 변하지 않도록 각 이미지의 너비와 높이를 설정해야 합니다:![데스크톱 뷰](/assets/img/sample/mockup.png){: width=\"700\" height=\"400\" }SVG의 경우 최소한 너비를 지정해야 합니다. 그렇지 않으면 렌더링되지 않습니다:위와 같이 width 및 height를 약어로 사용할 수 있습니다.위치기본적으로 이미지는 가운데 정렬되지만, normal, left, right 클래스 중 하나를 사용하여 위치를 지정할 수 있습니다.한 번 위치가 지정되면 이미지 캡션을 추가해서는 안됩니다.기본 위치이미지가 왼쪽에 정렬됩니다:![데스크톱 뷰](/assets/img/sample/mockup.png){: .normal }왼쪽에 띄우기![데스크톱 뷰](/assets/img/sample/mockup.png){: .left }오른쪽에 띄우기![데스크톱 뷰](/assets/img/sample/mockup.png){: .right }그림자프로그램 창의 스크린샷을 표시할 때 그림자 효과를 보여줄 수 있습니다:![데스크톱 뷰](/assets/img/sample/mockup.png){: .shadow }CDN URL이미지를 CDN에 호스팅하는 경우, 모든 이미지의 경로 앞에 반복해서 CDN URL을 작성하지 않아도 됩니다. 이를 위해 _config.yml 파일의 img_cdn 변수를 할당할 수 있습니다:img_cdn: https://cdn.comimg_cdn이 할당되면 /로 시작하는 모든 이미지의 경로에 CDN 접두사 https://cdn.com이 추가됩니다.예를 들어, 이미지를 사용하는 경우:![꽃](/경로/꽃.png)구문 분석 결과 이미지 경로 앞에 CDN 접두사 https://cdn.com이 자동으로 추가됩니다:&lt;img src=\"https://cdn.com/경로/꽃.png\" alt=\"꽃\" /&gt;이미지 경로게시물에 여러 이미지가 포함된 경우, 이미지의 경로를 반복해서 정의하는 것은 시간이 많이 걸릴 수 있습니다. 이를 해결하기 위해 게시물의 YAML 블록에서 이 경로를 정의할 수 있습니다:---img_path: /img/경로/---그런 다음 Markdown의 이미지 소스에서 파일 이름을 직접 작성할 수 있습니다:![꽃](flower.png)결과는 다음과 같습니다.&lt;img src=\"/img/경로/flower.png\" alt=\"꽃\" /&gt;미리보기 이미지게시물 상단에 이미지를 추가하려면 1200 x 630 해상도의 이미지를 제공하십시오. 이미지의 종횡비가 1.91 : 1에 부합하지 않는 경우 이미지가 크기 조정되고 잘려납니다.이러한 전제조건을 알고 나면 이미지의 속성을 설정할 수 있습니다:---image:  path: /경로/이미지  alt: 이미지 대체 텍스트---img_path도 미리보기 이미지에 전달될 수 있으며, 설정된 경우 path 속성에 이미지 파일 이름만 필요합니다.간단한 사용을 위해 이미지만 사용하여 경로를 정의할 수도 있습니다.---image: /경로/이미지---고정된 게시물홈 페이지 상단에 하나 이상의 게시물을 고정할 수 있으며, 고정된 게시물은 발행 날짜를 기준으로 역순으로 정렬됩니다. 다음으로 활성화할 수 있습니다:---pin: true---나머지 프롬프트, Syntax, 비디오 등은 직접 가셔서 보시길 바랍니다! ㅎㅎchirpy theme"
  },
  
  {
    "title": "소프트웨어 장인 정신",
    "url": "/posts/software-professional/",
    "categories": "소프트웨어 프로페셔널",
    "tags": "소프트웨어, software, professional, 책읽기",
    "date": "2024-04-05 00:00:00 +0900",
    





    
    "snippet": "소프트웨어 장인정신  읽은 책: 소프트웨어 장인소프트웨어 장인정신주관적인 정의  소프트웨어 장인정신은 마스터가 되어가는 긴 여정이다. 소프트웨어 장인 정신은 소프트웨어 개발자가 스스로 선택한 커리어에 책임을 가지고, 지속적으로 새로운 도구와 기술을 익히며 발전하겠다는 마음가짐이다.소프트웨어 장인 정신은 책임감, 프로페셔널리즘, 실용주의 그리고 소프트웨...",
    "content": "소프트웨어 장인정신  읽은 책: 소프트웨어 장인소프트웨어 장인정신주관적인 정의  소프트웨어 장인정신은 마스터가 되어가는 긴 여정이다. 소프트웨어 장인 정신은 소프트웨어 개발자가 스스로 선택한 커리어에 책임을 가지고, 지속적으로 새로운 도구와 기술을 익히며 발전하겠다는 마음가짐이다.소프트웨어 장인 정신은 책임감, 프로페셔널리즘, 실용주의 그리고 소프트웨어 개발자로서의 자부심을 의미한다.짧은 정의  소프트웨어 장인정신은 소프트웨어 개발의 프로페셜리즘에 대한 것이다.이 부분이 소프트웨어 장인정신에서 가장 중요한 내용이다.정의 이상의 의미소프트웨어 장인정신은 어떤 이념이나 마음가짐에 더 가깝다고 생각한다. 자신이 하는 일에 주인의식을 가지고 프로페셔널하게 행동하고, 고객이 원하는 것이 무엇이든 달성할 수 있도록 돕는다. 다른 개발자들에게 배우고 자신의 지식을 나누며, 경험이 부족한 개발자들을 멘토링 하는 것들이다.메니페스토  소프트웨어 장인을 열망하는 우리는, 스스로의 기술을 연마하고, 다른 사람들이 기술을 배울 수 있도록 도움으로써 프로페셔널 소프트웨어 개발의 수준을 높인다. 이러한 일을 하는 과정에서 우리는 다음과 같은 가치들을 추구한다.  동작하는 소프트웨어뿐만 아니라, 정교하고 솜씨 있게 만들어진 작품을,변화에 대응하는 것뿐만 아니라, 계속해서 가치를 더하는 것을,개별적으로 협력하는 것뿐만 아니라, 프로페셔널 커뮤니티를 조성하는 것을,고객과 협업하는 것뿐만 아니라, 생산적인 동반자 관계를,  이 왼쪽의 항목들을 추구하는 과정에서, 오른쪽 항목들이 꼭 필요함을 의미한다.기술적 실행 관례올바른 일 vs 올바른 실행일을 올바르게 제대로 수행하고 있다는 것은 어떻게 알 수 있을까? 코드의 품질과 설계에서는 빠르고 짧은 피드백 루프를 어떻게 만들 수 있을까?소프트웨어 장인정신은 기술적 실행 관례에 집중함으로써 코드의 품질에 대한 빠르고 짧은 피드백 루프를 제공해 애자일을 보완하는 효과가 있다.기술적 실행 관례들은 우리가 일을 ‘올바르게’하고 있는지 알 수 있게 해준다.실행 관례와 가치비즈니스 가치 중심어떻게 하면 팀(또는 관리자, 회사)에 TDD나 페어 프로그래밍같은 것들을 도입하도록 설득할 수 있는가?기술적 실행 관례들 그 자체를 직접적으로 팔려고 드는 것은 아무런 의미가 없다.현재 일하는 방식과 비교해서 그 것이 가져올 이익에 집중을 해야 한다.빠른 피드백 루프, 요구사항과 비용에 대한 더 나은 이해, 지식 공유, 줄어드는 버그, 전체적으로 자동화되고 릴리즈가 빨라지는 일들이 기술적 실행관례를 도입함으로써 얻을 수 있는 가치들이다.자동화된 테스트자동화된 테스트는 클릭 한번으로 전체 시스템을 단 몇 분만에 검증할 수 있게 해준다.코드가 올바른지 알려주는 피드백 루프가 몇 주에서 몇 분으로 줄어 들면 실수를 거의 즉시 고칠 수 있다.자동화된 테스트는 실제 측정 가능한 비즈니스적 가치를 가져다 준다.테스트 먼저아이디어를 생각해내는 데도 도움이 되고 한 번에 하나씩만 집중할 수 있다.테스트 코드가 준비되어 있으면 각 테스트 작업들은 몇 msec(단위 테스트)에서 몇 초(상위 수준 테스트)정도 소요되어 피드백 루프가 상당히 빨라진다.테스트 코드는 잘 정리된 요구사항의 역할도 하기 때문에 딱 필요한 만큼만 코딩하도록 유도한다.이러한 것들이 바로 비즈니스적인 가치다.테스트 주도 개발사실 TDD는 설계에 대한 실행 관례다. 테스트가 코딩 방향을 주도하면 복잡한 코드를 작성하는 것 자체가 어려워진다.정확히 요구사항만큼만 만족시키는, 즉 테스트로 규정된 부분만 작성하게 되기 때문이다.첫 설계 단계에서는 요구사항을 확대 해석하고 미래에 있을지 모를 부가 조건들이 추가되기 쉬워 설계가 커지고 복잡해지는(BDUF: Big Design Up Front) 경향이 있다.그렇게 되지 않도록 막아준다.코드가 복잡하고 방대하면 테스트 자체가 어렵기 때문이다.  TDD와 설계 리뷰 미팅이 서로 배타적인 것은 아니다. 둘 다 필요하다. 하지만 각각이 제공하는 가치와 피드백 루프의 주기가 다름을 이해하고 있어야한다.TDD는 코드의 설계, 단순성, 유지보수 용이성에 대해 피드백이 빠르다. 또한 코드에 대한 살아 움직이는 문서 역할을 한다.회귀 테스트 역할도 해준다. 이런 것들이 TDD가 주는 비즈니스적인 가치다.지속적인 통합  지속적인 통합은 TDD와 함께 수행되어 피드백 루프를 단 몇 분으로 줄일 수 있다.          QA팀을 통해서 변경점마다, 통합 때마다 테스트하는 것이다. 이 건 며칠에서 몇 주 후에 버그가 있는지 피드백을 받을 수 있다.        이러한 실행 관례는 ‘일단 멈추고 버그부터 수정한다는 태도가 필요하다.’  시스템이 항상 배포 가능한 상태로 유지되고 버그가 누적되지 않는다는 점에서 효율이 높다는 장점이 있다.  훌륭한 테스터는 자동화 하기 어려운 임의의 사용자 시나리오에 집중하여 개발자를 돕는다.페어 프로그래밍코드 리뷰는 시스템에 대한 지식과 유용한 코딩 스킬을 팀 전체에 전하는 데도 좋다. 중요한 것은, 설계 리뷰와 마찬가지로 얼마나 자주 하느냐다.여러가지 문제들로 인해서 피드백 루프의 주기가 길어질 가능성이 높다.하지만 페어 프로그래밍을 하면 코드가 작성되자마자 그 품질에 대해 피드백을 받을 수 있다같은 페어끼리 너무 오래 있으면 효과가 적다. 하루 이틀 단위로 주기적으로 페어를 바꾸는 것이 좋다.페어 프로그래밍은 팀의 지식을 공유하고, 코드의 품질을 높이며, 팀의 생산성을 높이는데 도움이 된다.이러한 것들이 비즈니스적인 가치다. 즉각적인 피드백 루프가 만들어진다.리팩토링레거시 애플리케이션을 대상으로 일을 할 때, 전체 시스템을 한꺼번에 새로 작성하고 싶은 욕구를 조심해야 한다.이럴 때는 수정되는 부분에 한정해서 리펙토링을 집중하는 것이 더 나은 접근 방법이다.프로페셔널로써 행동한다는 것은 트레이드오프를 이해한다는 것이다. 몇년동안 바뀐 적이 없는 부분을 리팩토링하는 것은 의미가 없다. 애당초 코드를 수정할 필요가 없다면, 리팩토링해야 할 이유도 없다. 유지보수가 쉬운 깨끗한 코드는 개발 속도를 높이고 버그가 만들어질 가능성을 낮춘다. 이 것이 리팩토링의 비즈니스적인 가치다.책임감각 실행 관례들의 가치를 설명함에도 불구하고 여전히 많은 사람들이 받아들이기를 거부한다.“그런 것들은 다른 데서 그렇게 하고 있다는 사례에 지나지 않는다. 그 중 많은 것들이 필요없다. 실행 관례들 없이도 좋은 소프트웨어를 쉽게 개발할 수 있다” 라는 말들이 여전히 반복해서 들리고 있다.그 것이 사실일 수도 있다 하더라도, 대단히 모호한 주장이다. 구글에서 실패한 소프트웨어 프로젝트 비율을 검색해보면 얼마나 많은 프로젝트들이 이런 저런 형태로 실패했는지 여러 보고 자료와 통게를 찾아볼 수 있다.출처에 따라 다르지만 실패 비율이 30%에서 70%에 이른다.개발자이든 프로젝트 매니저이든, 비즈니스 담당이든, 이러한 실행 관례를 원하지 않는다고 하면 귀담아 들어야 한다. 기분 나쁘게 생각하거나 그 사람의 지식 부족을 의심할 이유는 전혀 없다. 우리는 그런 사람들과의 대화에서 배워야한다.하지만 앞서 설명된 가치들을 이야기한 후 “이러한 가치와 최소한 동등한 수준의 가치를 만들어 내기 위해 당신은(혹은 우리는) 무엇을 하고 있습니까? 이러한 실행 관례보다 더 나은 방법이 있습니까?” 우리의 의사 결정에 책임감을 가져야 한다. 여기에는 실행 관례를 도입하지 않는 결정도 포함된다.관리자들 역시 팀이 특정 실행 관례를 따르지 못하도록 할 때 그에 대한 책임감이 있어야 한다.실용주의언제든지 TDD보다 더 나은 가치와 더 빠른 피드백 루프를 줄 수 있는 다른 것이 있다면 그 것을 TDD 대신 도입해야 한다.무언가를 절대적인 진리로 바라보는 것은 바람직하지 않다. 항상 우리가 무엇을 하고 있고 그것을 왜 하고 있는지 질문해야한다.어떤 실행 관례가 다른 실행 관례보다 더 나은지 알아보는 가장 좋은 방법은 프로젝트에 어떤 가치를 주는지, 피드백 루프가 얼마나 긴지 비교해보는 것이다.소프트웨어 장인 정신은 전이된다.실제로 글쓴이가 경험한 일을 기반하여 말하자면, 소프트웨어 장인 정신은 전이된다.한 회사에서 있었던 일인데, 글쓴이 본인이 문제가 산재해있었던 조직에 소프트웨어 장인을 여럿 모아서 일을 했던 경험이 있다.여러가지 방법들로 다시금 버그, 딜리버리 속도 등이 점진적으로 개선되었다.모든 변화를 추진하기 전에, 그런 변화들의 영향에 대해서 고려해야한다.많은 사람들에게 이야기를 하고 여러 종류의 회의론자들이 던질 수 있는 난감한 질문들에 답할 준비가 되어 있어야 한다.작업을 구현과 테스트로 나누어서는 안 된다. 실행 관례를 전파하는 가장 효율적인 방법은 모범을 보이는 것이다.나의 생각읽으면서 답답하고 불편한 마음이 계속 든다. 나는 소프트웨어 장인이 되고 싶다. 소프트웨어 장인이라는 단어를 생각하면 가슴이 두근 거린다.앞으로 나는 어떻게 해야할까? 어떻게 하면 소프트웨어 장인이 될 수 있을까?  첫번째로는 블로그 포스트를 작성하면서 나의 생각을 정리하고, 다른 사람들과 소통하고 싶다.  두번째로는 책을 읽는 것에만 그치는 것이 아닌 읽은 것을 정리하고, 일과 내 삶에 적용해볼 것이다.  세번째로는 새로운 기술을 배우고, 적용해보며 나의 역량을 키워나갈 것이다.  네번째로는 다른 사람들과 소통하며, 서로의 생각을 공유하고 배울 것이다.  다섯번째로는 나의 목표를 세우고, 그것을 달성하기 위해 노력할 것이다."
  },
  
  {
    "title": "구름 commit 우리가 함께 성장하는 방법(2023-12-20)",
    "url": "/posts/%EA%B5%AC%EB%A6%84-commit-%EC%9A%B0%EB%A6%AC%EA%B0%80-%ED%95%A8%EA%BB%98-%EC%84%B1%EC%9E%A5%ED%95%98%EB%8A%94-%EB%B0%A9%EB%B2%95/",
    "categories": "컨퍼런스",
    "tags": "컨퍼런스",
    "date": "2023-12-20 00:00:00 +0900",
    





    
    "snippet": "아래 글은 제가 2023년 12월 20일 구름 commit 프로그램을 참석한 뒤 류석문님의 강의를 토대로 개인적으로 쓴 글입니다.소프트웨어 개발 경험과 애자일 실천, 그리고 소프트웨어 장인정신폭포수 모델의 한계와 애자일 개발 방법론전통적인 폭포수 모델은 논리적으로 완벽해 보이지만, 변동성이 큰 현실을 반영하지 못한다는 단점이 있습니다. 이에 대한 대안...",
    "content": "아래 글은 제가 2023년 12월 20일 구름 commit 프로그램을 참석한 뒤 류석문님의 강의를 토대로 개인적으로 쓴 글입니다.소프트웨어 개발 경험과 애자일 실천, 그리고 소프트웨어 장인정신폭포수 모델의 한계와 애자일 개발 방법론전통적인 폭포수 모델은 논리적으로 완벽해 보이지만, 변동성이 큰 현실을 반영하지 못한다는 단점이 있습니다. 이에 대한 대안으로 등장한 애자일 개발 방법론은 상황에 맞춰 끊임없이 조정하고 점진적으로 구현하는 방식을 제시합니다. 하지만 애자일 방법론 역시 완벽한 해결책은 아닙니다.애자일 실천의 현실과 문제점애자일 방법론을 실천하는 과정에서 형식적인 데일리 스탠드업, 회고, 플래닝 등은 실질적인 문제 해결보다는 눈치 보기와 형식적인 절차에 치중하게 만드는 경우가 많습니다. 이는 애자일의 본질적인 가치를 훼손하고 개발 효율성을 저해하는 결과를 초래할 수 있습니다.소프트웨어 장인정신으로 기준 상향애자일의 한계를 극복하고 더 나은 소프트웨어 개발을 위해서는 ‘소프트웨어 장인정신’이 필요합니다. 단순히 작동하는 소프트웨어를 넘어 ‘잘 만들어진 소프트웨어’를 추구하고, 변화에 대응하는 것을 넘어 ‘꾸준히 가치를 더하는 것’을 목표로 해야 합니다. 또한, 개인과 상호작용을 넘어 ‘전문가 커뮤니티’를 형성하고, 고객과의 협업을 넘어 ‘생산적인 파트너십’을 구축해야 합니다.XP Practices: 익스트림 프로그래밍 실천법XP(eXtreme Programming)는 애자일 개발 방법론 중 하나로(켄트벡의 저서), 소프트웨어 개발 과정에서 실질적인 효과를 얻기 위한 구체적인 실천법을 제시합니다. XP Practices는 개발팀이 효과적으로 협업하고, 고품질의 소프트웨어를 빠르게 개발하며, 변화하는 요구사항에 유연하게 대응할 수 있도록 돕는 핵심 원칙입니다.핵심 XP Practices:      Test-Driven Development (TDD): 테스트 주도 개발은 개발자가 실제 코드를 작성하기 전에 테스트 코드를 먼저 작성하는 방식입니다. 이는 개발 초기 단계부터 오류를 발견하고 수정할 수 있도록 도와주며, 코드의 품질을 향상시키고 유지보수를 용이하게 합니다.        Refactoring: 리팩토링은 코드의 기능을 변경하지 않으면서 내부 구조를 개선하는 작업입니다. 지속적인 리팩토링을 통해 코드의 가독성과 유지보수성을 높이고, 기술 부채를 줄여 장기적인 개발 생산성을 향상시킬 수 있습니다.        Simple Design: 단순한 설계는 현재 요구사항을 충족하는 가장 간단한 방법으로 소프트웨어를 설계하는 원칙입니다. 불필요한 복잡성을 제거하고, 변경에 유연하게 대응할 수 있는 유연한 설계를 통해 개발 속도를 높이고 품질을 향상시킵니다.    Pair Programming: 짝 프로그래밍은 두 명의 개발자가 하나의 컴퓨터를 사용하여 함께 코드를 작성하는 방식입니다. 실시간 코드 리뷰, 지식 공유, 문제 해결 능력 향상 등 다양한 이점을 제공하며, 팀워크와 협업을 강화합니다.          TDD , Refactoring, Simple Design, Pair Programming 를 할 줄 알아야 개발자라고 하시는 류석문님…            Coding Standard: 코딩 표준은 팀 전체가 일관된 스타일로 코드를 작성하도록 규칙을 정의하는 것입니다. 코드의 가독성과 유지보수성을 높이고, 팀원 간의 협업을 원활하게 합니다.        Sustainable Pace: 지속 가능한 속도는 개발팀이 장기적으로 생산성을 유지할 수 있는 적절한 작업 속도를 의미합니다. 과도한 야근이나 무리한 일정을 지양하고, 팀원들의 건강과 워라밸을 존중하여 지속적인 성장을 도모합니다.        Metaphor: 메타포는 개발팀이 소프트웨어 시스템을 이해하고 설명하기 위한 공통된 비유나 은유를 사용하는 것입니다. 메타포를 통해 팀원 간의 의사소통을 원활하게 하고, 시스템에 대한 이해도를 높여 효과적인 협업을 가능하게 합니다.        Continuous Integration: 지속적인 통합은 개발자가 작성한 코드를 자주 통합하고 테스트하는 과정입니다. 이를 통해 통합 과정에서 발생하는 문제를 조기에 발견하고 해결하여 개발 속도를 높이고 품질을 향상시킵니다.        Collective Ownership: 공동 코드 소유는 모든 팀원이 모든 코드에 대한 책임을 공유하는 원칙입니다. 이는 특정 팀원에게 의존하는 것을 방지하고, 팀 전체의 역량을 활용하여 문제를 해결하고 코드 품질을 향상시킵니다.        Whole Team: 전체 팀은 개발에 필요한 모든 역할(개발자, 테스터, 분석가, 고객 등)을 팀에 포함시키는 것입니다. 팀원 간의 긴밀한 협업을 통해 요구사항을 정확하게 이해하고, 빠르게 변화하는 환경에 유연하게 대응할 수 있습니다.        Planning Game: 계획 게임은 팀 전체가 참여하여 개발 우선순위를 정하고, 작업량을 추정하는 활동입니다. 팀원 간의 활발한 논의를 통해 상호 이해를 높이고, 현실적인 계획을 수립하여 개발 목표를 효과적으로 달성할 수 있도록 돕습니다.        Small Releases: 작은 릴리스는 개발된 기능을 작은 단위로 자주 배포하는 방식입니다. 사용자 피드백을 빠르게 반영하고, 문제 발생 시 신속하게 대응하여 개발 위험을 줄이고 사용자 만족도를 높입니다.    Customer Tests: 고객 테스트는 실제 사용자가 직접 소프트웨어를 테스트하고 피드백을 제공하는 과정입니다. 사용자의 요구사항을 정확하게 파악하고, 실제 사용 환경에서 발생하는 문제를 조기에 발견하여 소프트웨어 품질을 향상시킵니다.좋은 개발자란 뭘까요?좋은 개발자는 뛰어난 코드 작성 능력과 논리력을 기반으로 협업과 공유를 통해 시너지를 창출합니다. 또한, 깊이 있는 도메인 지식을 갖추고 빠른 피드백을 통해 끊임없이 성장하며, 실천력을 바탕으로 아이디어를 현실화합니다.협업의 중요성과 어려움 극복협업은 개발 효율성을 높이고 더 나은 결과물을 만들어내는 데 필수적입니다. 하지만 인간은 본능적으로 자기중심적인 사고를 하기 때문에 협업 과정에서 어려움을 겪을 수 있습니다. 이를 극복하기 위해서는 상대방의 입장에서 생각하고, 열린 마음으로 소통하며, 서로의 의견을 존중하는 자세가 필요합니다.결론소프트웨어 개발은 단순히 기술적인 문제 해결을 넘어 사람과의 상호작용, 끊임없는 학습과 성장, 그리고 협업을 통한 시너지 창출이 중요합니다. 소프트웨어 장인정신을 바탕으로 끊임없이 배우고 성장하며, 동료들과 함께 더 나은 소프트웨어를 만들어나가는 것이 진정한 개발자의 길이라고 할 수 있을 것 같습니다.류석문님의 책  프로그래머로 산다는 것  프로그래머 철학을 만나다  리더의 생각  리더의 세상읽기나의 생각류석문님이 당시에 쏘카 CTO 직책을 맡고 계셨었는데, 개발이란 업을 하시면서 얼마나 많은 생각을 하셨을지 감히 짐작도 안갈만큼 깊이 있는 강의 내용이었다고 생각합니다. XP Practices나 에자일이나 그 단어가 중요한 것이 아니라 본질적인 내용이 더 중요하다고 느껴졌습니다. 저도 좋은 동료와 함께 좋은 동료가 되어 더 나은 소프트웨어를 만들어가는데 일조하는 구성원이 되었으면 좋겠고, 실질적으로 여태까지 쌓은 경험들을 공유하는 것부터 시작해보려 합니다."
  },
  
  {
    "title": "스타트업에서의 팀",
    "url": "/posts/%EC%8A%A4%ED%83%80%ED%8A%B8%EC%97%85%EC%97%90%EC%84%9C%EC%9D%98-%ED%8C%80/",
    "categories": "내생각",
    "tags": "",
    "date": "2023-04-28 00:00:00 +0900",
    





    
    "snippet": "서두팀이란 뭘까요? 우선 위키에서 검색해봤습니다.  ‘팀(Team)’이란 공동의 목적 안에서 연결된 사람들의 집단을 뜻한다. 집단이 반드시 팀을 구성하는 것은 아니다. 팀은 보통 서로 상호보완적인 기술을 지닌 선수들을 가지고 있으며, 선수들이 각각 그들의 강점은 최대화하고, 약점은 최소화할 수 있는 협조적인 노력을 통해 시너지를 낸다.위키에서 말하듯이...",
    "content": "서두팀이란 뭘까요? 우선 위키에서 검색해봤습니다.  ‘팀(Team)’이란 공동의 목적 안에서 연결된 사람들의 집단을 뜻한다. 집단이 반드시 팀을 구성하는 것은 아니다. 팀은 보통 서로 상호보완적인 기술을 지닌 선수들을 가지고 있으며, 선수들이 각각 그들의 강점은 최대화하고, 약점은 최소화할 수 있는 협조적인 노력을 통해 시너지를 낸다.위키에서 말하듯이, 팀이란 같은 공동의 목적을 가지고 상호보완적인 플레이어들이 속한 집단이라 합니다.제 경험적으로 소프트웨어 개발에 입문하기 전 직장(대기업)에서는 팀에 가깝기보다는 개인주의에 가깝다고 볼 수 있었습니다.물론 제가 속해있었던 조직은 현장이고 특수한 환경이었기 때문에 어떤 문화를 권장해야했는지는 잘 모르겠지만 말입니다.전 직장 얘기를 해보자면, “수평적 조직 구조, 님 문화” 등으로 유명한 회사였으며, 국내 대기업 100위 내에 있는 회사였습니다.하지만 그 내부에 있었던 이들은 표면적으로만 수평적 조직, 님 문화를 포용하는 척 했지 진심으로 그 목적에 대해 공감하는 이는 없었다고 자부합니다.그럼 어떤 문제가 있었을까요?  잘못이 있으면 개인의 잘못이다.  잘한 건 상사의 능력이다.  문제를 해결하기보다는 문제를 덮기에 급급하다.  긴 일정의 목표를 정해놓고 수시로 목표를 같이 확인하는게 아닌 일정에 도달하면 도달률만 체크한다.  그렇다고 따로 성과 지표는 존재하지 않는다.  상사 X꼬 잘 빠는 사람이 평가를 좋게 받는다.이런 문제들이 있었기에 더 이상 해당 조직에 남아있고 싶지 않았습니다.또한 같은 직업으로 다른 직장을 다녀도 이 조직 문화는 더 나빠지면 나빠졌지 더 이상 좋아지기는 힘들겠다는 판단하에 퇴사하게 되었습니다.(물론 “조직 문화” 가 안좋다는 이유만으로 퇴사했던 것은 아닙니다.)그럼 스타트업에서의 조직은?제가 소프트웨어 개발자로 전향하고, 스타트업 2곳을 경험하면서 여전히 해당 문제가 없었던 것은 아닙니다.하지만 젊은 사람들이 모여있다보니 뭐든 알고 있다면 언제든지 개선할 수 있다고 생각헀고, 실제로 개선이 되었었던 적도 있었습니다.그럼 제가 생각하는 스타트업에서의 조직은 어떤 모양일까요?  잘못이 있으면 개인의 잘못이 아닌 팀의 잘못이고, 개인을 탓하기 보다는 팀에서 다음에 같은 잘못을 하지 않도록 보완한다.  잘한 건 팀의 능력이다.  문제가 발생하면 같이 해결한다.  목표를 짧게 정해놓고 수시로 목표를 같이 확인하고 나아가야할 방향을 같이 정한다.  능력(소프트스킬 등)이 뛰어난 사람이 평가를 좋게 받는다.이 모양이면 팀이라고 할 수 있겠습니다.스타트업에서 팀이란 것이 왜 중요할까요? 혼자 일하는 것이 아니기 때문입니다.현대에는 영웅이 필요하지 않습니다.협력과 커뮤니케이션으로 목표를 같이 달성해야합니다. 우리가 해결할 문제는 수학 7대 난제와 같은 것이 아닌 사용자의 문제를 해결하고 가치를 제공하는데 있습니다.조직을 팀으로 바꾸는 과정  전쟁을 마친 군인을 환대하는 의미에서 식량을 나누고 잔치를 벌이는게 풍습이지만, 식량이 아주 부족한 시대에 군인 두 명이 한 마을에 도착했고, 마을 사람들은 문을 굳게 닫았다.군인들은 너무 배고픈 나머지 기발한 아이디어를 냈고, 장작 불에 냄비를 얹고 돌멩이 세개를 넣고 끓였다“돌멩이만 넣고도 아주 맛있는 스프를 만들 수 있습니다.”그러자 사람들이 몰려들었다.군인들은 말했다“양배추를 조금 넣으면 더 맛있을텐데…”한 마을 사람이 당장 달려가 집에 조금 남은 양배추를 수프에 넣었다.그러자 군인들은“감자를 넣으면 더 맛있어질텐데…”한 마을 사람이 집에서 감자를 가져와 수프에 넣었다.여기저기에서 집에 조금 남은 “당근을 넣으면 더 맛있어 질까요?” “집에 남은 소세지가 있어요” 등 여러 식량들을 가지고 온 덕분에 근래들어 최고로 성대한 잔치를 벌였다이 이야기는 돌멩이 수프라는 유명한 동화인데요. 이 이야기를 통해 우리는 협력이 어떤 힘을 지니는지 알 수 있습니다.그리고 한 가지 더. 실제로 조직을 바꿀 수 있습니다.이 말인 즉슨, 지금 속해있는 조직에 최선을 다 해보라고 말씀드리고 싶습니다.조직을 바꾼다는게 정말 어려운 일이지만, 일단 조직 내에서 사람들의 마음을 사세요.그들의 마음에 들게되고 자신을 좋아하게 된다면 여러 문화를 도입해보세요.“코드 리뷰 문화를 도입하고 싶어요”, “형상 관리 툴로 git을 사용하고 싶어요” 등이요.행동하지 않으면 아무 것도 바뀌지 않습니다.최선을 다 해보고 실패해도 잃을 것이 없습니다. 이게 모두 우리의 “성장통” 이니까요."
  },
  
  {
    "title": "토이프로젝트 회고",
    "url": "/posts/%ED%86%A0%EC%9D%B4%ED%94%84%EB%A1%9C%EC%A0%9D%ED%8A%B8-%ED%9A%8C%EA%B3%A0/",
    "categories": "회고",
    "tags": "retrospect, 회고",
    "date": "2021-06-16 00:00:00 +0900",
    





    
    "snippet": "docker, WSL2, linux OS, Cloud Server(NCP), nginx, Spring boot, JPA,Spring data JPA, QueryDSL, AWS S3https://okky.kr 에 토이프로젝트 구인글을 올렸고, 뜻대로 프론트개발자 2명, 서버개발자 1명을 모집하여총 구성인원은 프론트개발자 2명, 서버개발자 본인포함 2명,...",
    "content": "docker, WSL2, linux OS, Cloud Server(NCP), nginx, Spring boot, JPA,Spring data JPA, QueryDSL, AWS S3https://okky.kr 에 토이프로젝트 구인글을 올렸고, 뜻대로 프론트개발자 2명, 서버개발자 1명을 모집하여총 구성인원은 프론트개발자 2명, 서버개발자 본인포함 2명, 웹 디자이너까지 5명이었다.프로젝트 리딩이 이토록 조원 컨트롤이 안될줄은 몰랐다.게다가 접점이 있는 사람들이 아니었다보니 더욱 힘들었던 것 같다.기획단계기획단계에선 조원들의 여러 의견과 아이디어를 조합하여 최종적으로 중고책거래 웹 어플리케이션이 뽑혔다.요구사항 등을 적절히 분석하지 못했는지, 기획단계에선 부족한점이 많았다고 생각한다.협업툴의 중요성을 실감하게 된 계기가 되지 않았나 싶다. 노션 무료버전은 너무나 스토리지가 작았다.설계단계프로젝트 기간이 충분하다고 생각하지 않았는데도 불구하고 많은 기능을 구현하려 했다.돌이켜보면 기능을 줄이고, 기능을 구현하는데 집중했어야 했는데, 그렇지 못했다.기술스택FE 언어는 typescript를 적용해보고 싶다 하여 승인하였다.처음 개발에 적용해봐서 그런지 프론트엔트 개발 속도가 나질 않았다.BE 언어는 java 11버전을 사용하였으며, 람다와 스트림을 사용해보려 노력해보았다.자잘한 얘기국비지원학원 프로젝트 이후 다시 한번 깨달은 점은, 토이프로젝트에서 책임감이 결여된 조원과의 커뮤니케이션은 상당히 어렵다는 것이었다.그래서 나는 최대한 많이 조원들과 얘기 나누고, 시간을 같이 보내려 노력했었다.클라우드 서버를 이용해서 배포를 처음 해보았는데, 배포하며 리눅스, 정적웹서버(프록시서버), ssl(https) 등을 적용하며 서버 관련하여 많이 깨달았다.docker로 centOS 이미지를 조원들에게 배포하였는데, 클라우드 서버 환경과 동일하게 구성하며 개발 환경을 조성하였다.도커를 사용해보지 않았던 조원들에게 사용법을 공유하고 서버 환경등을 설명하느라 시간을 많이 잡아먹었다.리눅스 CLI에 조금은 익숙해져 너무 좋았다.무중단 배포, jenkins등을 공부해보고 싶은 계기가 되었다.일일히 빌드된 파일을 서버에 전송하였는데, 상당히 번거로운 일이었다.여기서 구글드라이브를 사용하였고, gdown이라는 라이브러리를 사용하였다.처음 DB 설계 후 JPA 설계를 하였고, 연관관계 중 @ManyToOne 등의 default FetchType은 Eager이었으므로, 원치않는 쿼리가 자꾸 나가 모든 전략을 LAZY로 설정하여 작업 하였다.스스로 N + 1 쿼리를 짜지 않도록 유의하여 개발하였다.알라딘 api를 적용하여 책 카테고리 등을 받아왔는데, 프록시서버 구성으로 cors 문제는 발생하지 않도록 설계하였다.게시물 필터링 적용이 필요하여, jpql 로 개발하였는데, 개발하다 querydsl을 알게되어 querydsl 사용하여 동적쿼리를 구성하였다.select(new QArticleDTO(                    articleDAO.article_id,                    articleDAO.countDAO,                    articleDAO.title,                    articleDAO.tprice,                    articleDAO.progress,                    articleDAO.category,                    articleDAO.member.nickname,                    articleDAO.write_date,                    articleDAO.imageInfo.image1))            .from(articleDAO)            .join(articleDAO.member, memberDAO)            .join(articleDAO.countDAO, countDAO)            .join(articleDAO.category, book_CategoryDAO)            .join(articleDAO.imageInfo, image_infoDAO)            .where(                    articleLatGoe(member),                    articleLatLoe(member),                    articleLngGoe(member),                    articleLngLoe(member),                    titleLike(articleSearchCondition.getTitle()),                    articleIdLt(articleSearchCondition.getLastId()),                    divisionEq(division),                    articleDAO.market.isNull(),                    articleDAO.category.cid.in(                            JPAExpressions                                    .select(book_CategoryDAO.cid)                                    .from(book_CategoryDAO)                                    .where(                                            one_depthEq(categoryList[0]),                                            two_depthEq(categoryList[1]),                                            three_depthEq(categoryList[2]),                                            four_depthEq(categoryList[3]),                                            five_depthEq(categoryList[4]))),                    articleDAO.progress.eq(Progress.POSTING).or(articleDAO.progress.eq(Progress.TRADING))            )            .limit(10)            .orderBy(articleDAO.article_id.desc())            .fetch(); =&gt; 이 쿼리는 문제가 있는데, 페이징 처리시에 모든 데이터를 가져와서 메모리에 올리고, 그 후에 애플리케이션 레벨에서 페이징 처리를 하게 된다. 이는 성능에 좋지 않다.해결하기 위해선, Join을 하지 않고, 가져오려는 데이터만 가져와서 페이징 처리를 애플리케이션 레벨에서 하지 않고 DBMS 레벨에서 처리하도록 하고, 필요한 데이터들의 ID를 이용해서 다시 한번 쿼리를 날려서 데이터를 가져오는 방법이 있다.  http://www.querydsl.com/를 참조하여 개발하였다.토이프로젝트가 끝난 후 결심  gradle build tool에 대해서도 공부할 예정이다.  특히 기초가 부족하기 때문에 cs와 알고리즘, 자료구조 등을 지속적으로 공부할 예정이다.여러모로 우리에게 벅찬 프로젝트채팅까지 구현하고 싶었으나,(백엔드 개발은 거의 완료된 상태) 프로젝트 조원의 탈주로 인해 프로젝트를 연장은 하되, 일단락 짓기로 마음을 먹은 상태이다.협업툴과 일정관리가 정말 중요하다는 생각이 들었고, 똑같은 실수를 반복하지 않을 것이라 굳게 다짐하였다."
  }
  
]

